# 類別的繼承
> JAVA可根據既有類別為基礎，進而衍伸出另一類別。

## 繼承 (inheritance)

|既有的類別|衍伸出的類別|
|---------|-----------|
|父類別(super class)|子類別(sub class)|
|基底類別(basis class)|衍出類別(derived class)|

### 分類：

* 單一繼承 (single inheritance): JAVA  
  每一個類別只能有一個父類別
* 多重繼承 (multiple inheritance): C++
  一個父類別可以擁有一個以上的子類別

### 繼承內容

* 可直接繼承
  * 沒有宣告成public或private的成員
  * public成員
  * protected成員
* 不能直接在子類別存取，只能透過父類別的函數做存取
  * private成員
* 不能繼承
  * 建構元
  * 設定終止繼承的成員

### 關鍵字
> 透過繼承的方式，使得某個物件的資源得以重複使用。
```java
extends
```

```java
class 父類別名稱
{
    //父類別裡的成員
}

class 子類別名稱 extends 父類別名稱
{
    //子類別裡的成員
}
```

1. 透過 extends 關鍵字,可將父類別的成員(包含資料成員與函數成員)繼承給子類別。。

2. Java 在執行子類別的建構元之前,會先呼叫父類別的建構元,其目的是為了要幫助繼承自父類別的成員做初始化的動作。

### 建構元的呼叫
> 在子類別的建構元中，透過該關鍵字呼叫父類別的建構元
```java
super()
```
Java 在執行子類別的建構元之前,如果沒有用 super()來呼叫特定父類別的建構元,  
則會先呼叫父類別中"沒有引數的建構元"。因此,如果父類別中只定義有引數的建構元
(此時Java不再提供父類別預設的建構元),而在子類別的建構元裡又沒有用 super() 来呼叫父類別中特定的建構元的話,則編譯時將發生錯誤,因為Java 在父類別中找不到"沒有引數的建構元"可供執行。

## ```this()``` v.s. ```super()```
|     this()     |     super()     |
|------|-------|
|在同一類別內呼叫其他建構元|從子類別內呼叫父類別的建構元|
|能支援建構元多載|能支援建構元多載|
|須寫在建構元的第一行|須寫在建構元的第一行|

※ this() 與 super() 無法共存在同一個建構元內

## 存取父類別的資料成員與函數成員

```java
super.資料成員名稱
```
```java
super.函數名稱
```

# 保護成員 (protected members)

若子類別欲存取位於父類別，會出現無法存取之錯誤訊息。  
因為原先的資料成員被宣告為```private```  
e.g. app10_2_1.java
```
app10_2_1.java:34: error: radius has private access in CCircle
        radius = r;
        ^
1 error
```
## 使子類別能存取被保護的資料成員
```java
protected
```
把成員宣告成 protected 最大的好處是可同時兼顧到成員的安全性與便利性,  
因為它只能供父類別與子類別的內部來存取,外界無法更改或讀取。  
附帶一提,父類別裡的 protected 成員,繼承到子類別之後,其存取的屬性還是 protected。

# 改寫 (overriding)
> 與「多載」相似，均是JAVA「多型(polymorphism)」的技術之一

利用「改寫」的技術,於子類別中可定義和父類別裡之名稱、引數個數與資料型態均完全相同的函數,  
用以取代父類別 中原有的函數。

## 多載 v.s. 改寫

||多載|改寫|
|-|---------|-----------|
|英文名|overloading|overriding|
|關係|相同類別內|子類別中|
|功能|根據引數的葛數或形態，呼叫相對應的函數|改寫父類別裡的函數|

## 以父類別的變數存取子類別的成員
1. 透過父類別的變數仍然可以存取到子類別物件的成員
2. 透過父類別的變數存取子類別物件的成員，僅限於「**改寫**」的情況發生時。  
   (父類別與子類別的函數名稱、引數個數與型態必須完全相同)

   